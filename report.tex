\documentclass{article}

\usepackage[utf8]{inputenc}
%\usepackage{xunicode}
\usepackage[T1]{fontenc}
%\usepackage{fontspec}
\usepackage{geometry}
\usepackage[english]{babel}
%\usepackage{polyglossia}
%\setmainlanguage{english}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{unicode-math}
\usepackage{hyperref}
\usepackage{enumitem}
\setlist{nosep,leftmargin=*}
\frenchspacing

\newcommand\setR{\mathbb{R}}
\newcommand\setZ{\mathbb{Z}}
\newcommand\setN{\mathbb{N}}

\title{Array expansion in function arguments and return values}
\author{Quentin \textsc{Corradi}}
\setlength{\parindent}{0pt}

% TODO: biblio (Jasmin articles, array contraction)

\begin{document}

\maketitle

\section{Introduction}

Arrays are an abstraction for handling memory using integers. It abstracts
contiguous memory into a partial map from integers to memory cells. This
abstraction could also be conceived as a partial map from integers to variables.
This means any array \(t\) of size \(N\) could be replaced by \(N\) variables
\(t_0, \dots, t_{N - 1}\) and a pair of functions
\((\mathit{get}, \mathit{set})\) such that \(\mathit{get} : k \mapsto t_k\) and
\(\mathit{set}\;k\;x\) sets \(t_k\) to \(x\).

\smallskip

The idea of array expansion is that the above interpretation of arrays can be
used litterally as it doesn't need contiguity of variables in memory or any
hardware support for integer indexing while still allowing all common operations
on arrays: An array whose size is known can be replaced during compilation by as
many variables as necessary, simplifying access to some kind of indicies to
simple variable accesses.

\smallskip

Jasmin is a compiler targetted at ???.
 Jasmin est un compilateur utilisé pour la crypto, il est associé d'une preuve
 de correction et de préservation de constant-time.
The Jasmin language is close to assembly, the main differences lies in:
\begin{itemize}
\item Jasmin abstracts numerical operations common in cryptography
\item Jasmin provides variables and performs variable allocation in registers
\item Jasmin supports arrays
\item Jasmin provides common control flow statements
\item Jasmin provides functions with support for C calling convention if needed
\end{itemize}\smallskip

In Jasmin there are two kind of variables, the stack allocated ones and the
register allocated ones. The user has to tell the compiler the kind of every
variables. This also holds true for arrays. However on most processor on which
people run ??? software there is no hardware support for indexing registers with
a value not encoded in the instruction. So some compilation step eliminates
these arrays.

\smallskip

In this article we did not implement most of the array expansion the Jasmin
compiler already performs. Instead we extended this transformation for some
previously unsupported cases, namely expanding register arrays in function
arguments and return values. 

\medskip

This article is organised as follows:
In Section \ref{sec:syntax} the relevant parts of Jasmin syntax trees are
presented then the syntactic side of array expansion is explained more in-depth
for our intended use in Jasmin.
In Section \ref{sec:semantics} the relevant parts of Jasmin semantics are
presented then the semantic side of array expansion is explored.
% TODO: In section \ref{sec:???}

 Présentation des modifications de la sémantique au niveau des fonctions ainsi
 que des varmap, avec les propriétés importantes et l'élimination des types
 dépendants pour justifier les choix. Et de la transformation effectuée.

 Présentation du travail restant dans le stage ainsi que potentiellement après
 le stage: FIXER LES PREUVES

\begin{figure}[!b]
\obeylines\obeyspaces\fbox{\parbox{\textwidth}{\ttfamily%
type ty =
| Word of wsize
| Arr  of wsize \(\times\;\setN\)

type v\_kind =
| Stack of pointer
| Reg   of reg\_kind \(\times\) pointer

type var = \{
~ v\_id   : uid;
~ v\_kind : v\_kind;
~ v\_ty   : ty;
\}

type expr =
| Pconst of wsize \(\times\;\setZ\)
| Parr\_init of wsize \(\times\;\setN\)
| Pvar   of var
| Pget   of arr\_access \(\times\) var \(\times\) expr
| Psub   of arr\_access \(\times\;\setN\;\times\) var \(\times\) expr

type lval =
| Lnone
| Lvar  of var
| Laset of arr\_access \(\times\) var \(\times\) expr
| Lasub of arr\_access \(\times\;\setN\;\times\) var \(\times\) expr

type instr =
| Cassgn of lval \(\times\) expr
| Ccall  of lval list \(\times\) uid \(\times\) expr list

type call\_conv =
| Export
| Subroutine

type func = \{
~ f\_cc   : call\_conv;
~ f\_name : uid;
~ f\_args : var list;
~ f\_body : instr list;
~ f\_ret  : var list;
\}

type prog = func list}}
\caption{Simplified version of the relevant parts of Jasmin programs AST.}\label{fig:types}
\end{figure}


\section{Array expansion compiler pass}\label{sec:syntax}

\subsection{Introduction to relevant parts of Jasmin syntax}

In this section, the relevant parts of Jasmin programs are described. The
irrelevant parts, if mentioned, will not be expanded upon.

A Jasmin progam is a list of functions among other things. A function is made
among other things of its name, a unique identifier; its parameters, a list of
variables; its body, a list of statements; its returned variables, a list of
variables; and its kind. The kind of a function can be exported to the outside,
in which case the function must follow some calling convention, or internal.

\smallskip

A statement can be an assignment or a function call.
Other statements include assembly instructions and control flow statements,
however they are not relavant to us.

An assignment is made of a left member and an expression. A function call is
made of the called function identifier, a list of left members matching the
function returned variables list on length, and a list of expression matching
the function parameters list on length.

Function arguments and return variables, left members and expressions refer to
variables. A variable is made of an identifier, a type and a kind. In the AST a
variable doesn't have to be declared in order to be used. Across a function
body, parameters and returned variables, all variables featuring the same
identifier are considered to be the same. A variable kind is either stack or
register. It indicates where the variable is stored.

\smallskip

A type can be a word of some size (a power of 2 bytes) or an array of some
length over words of some size. Arrays are indexed by two means, the first is
by considering the array as cells of some size, the other is by considering it
as a sequence of bytes (independently of the size of the data being accessed at
the index).

Arrays can be built out of other arrays by taking a slice. A slice is a
contiguous section of some length at an offset of the begining of an array.

\smallskip

A left members is either a variable, a cell of an array variable, a slice of an
array variable or the discard.

An array cell is indexed by an expression, its size is a word size. An array
slice length and offset are expressions, the cell size is a word size. The
discard left member does not store the value it is assigned.

An expression can be a constant word, an empty array, a variable, a cell of an
array variable or a slice of an array variable. Operations are also expressions
made of other expressions.

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
Fixpoint expand\_e m e := 
~ match e with
~ | Pvar x \(\Rightarrow\) if expand\_var m x is Some \_ then Error else Ok (Pvar x)
~ | Pget aa x e \(\Rightarrow\) if expand\_var m x is Some vx then
~     assert (aa == AAscale) in
~     if e is Pconst \_ z then if get vx z is Some v then Ok (Pvar v)
~     else Error else Error
~   else Let e := expand\_e m e in Ok (Pget aa x e)
~ | Psub aa len x e \(\Rightarrow\) if expand\_var m x is Some \_ then Error
~   else Let e := expand\_e m e in Ok (Psub aa len x e)
~ | \_ \(\Rightarrow\) Ok e
~ end.

Definition expand\_lv m x :=
~ match x with
~ | Lvar x \(\Rightarrow\) if expand\_var m x is Some \_ then Error else Ok (Lvar x)
~ | Laset aa x e \(\Rightarrow\) if expand\_var m x is Some vx then
~     assert (aa == AAscale) in
~     if e is Pconst \_ z then if get vx z is Some v then Ok (Lvar v)
~     else Error else Error
~   else Let e := expand\_e m e in Ok (Laset aa x e)
~ | Lasub aa len x e \(\Rightarrow\) if expand\_var m x is Some \_ then Error
~   else Let e := expand\_e m e in Ok (Lasub aa len x e)
~ | \_ \(\Rightarrow\) Ok x
~ end.
\normalfont%
\caption{Simplified version of expression and left member expansion in Jasmin.}
\end{figure}

\subsection{Array expansion in Jasmin compiler}

\begin{figure}[p]
\obeylines\obeyspaces\ttfamily%
Fixpoint expand\_e m e := 
~ match e with
~ | Pvar x \(\Rightarrow\) if expand\_var m x is Some vx
~   then Ok (inr [:: Pvar v | v \(\leftarrow\) vx ]) else Ok (inl (Pvar x))
~ | Pget aa x e \(\Rightarrow\) if expand\_var m x is Some vx then
~     assert (aa == AAscale) in
~     if e is Pconst \_ z then if get vx z is Some v then Ok (inr [:: Pvar v ])
~     else Error else Error
~   else Let inl e := expand\_e m e in Ok (inl (Pget aa x e))
~ | Psub aa len x e \(\Rightarrow\) if expand\_var m x is Some vx then
~     assert (aa == AAscale) in
~     if e is Pconst \_ z then Ok (inr [:: Pvar v | v \(\leftarrow\) take len (drop z vx) ])
~     else Error
~   else Let inl e := expand\_e m e in Ok (inl (Psub aa ws len x e))
~ | \_ \(\Rightarrow\) Ok (inl e)
~ end.

Definition expand\_lv m x :=
~ match x with
~ | Lvar x \(\Rightarrow\) if expand\_var m x is Some vx
~   then Ok (inr [:: Lvar v | v \(\leftarrow\) vx ]) else Ok (inl (Lvar x))
~ | Laset aa x e \(\Rightarrow\) if expand\_var m x is Some vx then
~     assert (aa == AAscale) in
~     if e is Pconst \_ z then if get vx z is Some v then Ok (inr [:: Lvar v ])
~     else Error else Error
~   else Let inl e := expand\_e m e in Ok (inl (Laset aa x e))
~ | Lasub aa len x e \(\Rightarrow\) if expand\_var m x is Some vx then
~     if e is Pconst \_ z then Ok (inr [:: Lvar v | v \(\leftarrow\) take len (drop z vx) ])
~     else Error
~   else Let inl e := expand\_e m e in Ok (inl (Lasub aa len x e))
~ | \_ \(\Rightarrow\) Ok (inl x)
~ end.

Definition expand\_fvar m v :=
~ if expand\_var m v is Some vx then (Some (size vx), vx) else (None, [:: v ]).

Definition expand\_fsig m fd :=
~ let \{| f\_cc; f\_name; f\_args; f\_body; f\_ret |\} := fd in
~ if f\_cc == Export then (fd, None) else
~ let (args, expargs) := split [:: expand\_fvar m v | v \(\leftarrow\) f\_args ] in
~ let (ret,  expret)  := split [:: expand\_fvar m v | v \(\leftarrow\) f\_ret  ] in
~ (\{| f\_cc; f\_name; f\_args := flatten args; f\_body; f\_ret := flatten ret |\},
~   Some (expargs, expret)).
\normalfont%
\caption{Simplified version of expression, left member and functon signature ideal expansion.}
\end{figure}

A variable of type array and kind register means an array of register, but in
most common processor on which ??? programs are run there is no hardware support
for register indexing outside of the processor instruction opcode. Therefore we
need to eliminate them in some compilation step; this is what the array
expansion step does in the Jasmin compiler. Other kind of arrays are not
expanded --even though we could expand them-- because there is hardware support
for the operation performed on them and so we consider users know what they want.

\medskip

We want to replace all store and load operations on an array. There are two way
to index on array as described in the previous section. The accesses where the
index is an offset in bytes from the start of the array would require
concatenating parts of registers together on loads or assigning portions of a
value into portions of registers on stores. While this is completely possible we
do not want to provide it so a program with this access scheme used on a
register array will fail to compile.
The accesses we have to deal with are of three kind: single cell indexing,
array slicing and whole array access.

\smallskip

\begin{figure}[p]
\obeylines\obeyspaces\ttfamily%
Definition expand\_e\_n m e n :=
~ match e with
~ | Pvar (\{| v\_ty := Arr s \_ |\} as x) \(\Rightarrow\)
~   Ok (mkseq n \(\lambda\)i, Pget AAscale v (Pconst U64 i))
~ | Psub aa len (\{ v\_id; v\_kind; v\_ty := Arr s \_ |\} as x) e \(\Rightarrow\) match e with
~   | Pconst \_ \_ | Pvar \_ \(\Rightarrow\)
~     Ok (mkseq n \(\lambda\)i, Pget aa v (Padd e (Pconst U64 (i * s))))
~   | \_ \(\Rightarrow\) Error
~   end
~ | \_ \(\Rightarrow\) Error
~ end else Error.
 
Definition expand\_lv\_n m x n :=
~ match x with
~ | Lnone \(\Rightarrow\) Ok (nseq n Lnone)
~ | Lvar (\{| v\_ty := Arr s \_ |\} as v) \(\Rightarrow\)
~   Ok (mkseq n \(\lambda\)i, Laset AAscale v (Pconst U64 i))
~ | Lasub aa len (\{ v\_id; v\_kind; v\_ty := Arr s \_ |\} as x) e \(\Rightarrow\) match e with
~   | Pconst \_ \_ | Pvar \_ \(\Rightarrow\)
~     Ok (mkseq n \(\lambda\)i, Laset aa v (Padd e (Pconst U64 (i * s))))
~   | \_ \(\Rightarrow\) Error
~   end
~ | \_ \(\Rightarrow\) Error
~ end else Error.

Definition expand\_arg m ex e :=
~ match ex, expand\_e m e with
~ | Some \_, Ok (inr es)  \(\Rightarrow\) Ok es
~ | Some n, Ok (inl e)   \(\Rightarrow\) expand\_e\_n m e n
~ | None  , Ok (inl e)   \(\Rightarrow\) Ok [:: e ]
~ | \_                    \(\Rightarrow\) Error
~ end.

Definition expand\_ret m ex x :=
~ match ex, expand\_lv m x with
~ | Some \_, Ok (inr xs)   \(\Rightarrow\) Ok xs
~ | Some n, Ok (inl x)    \(\Rightarrow\) expand\_lv\_n m x n
~ | None  , Ok (inl x)    \(\Rightarrow\) Ok [:: x ]
~ | \_                     \(\Rightarrow\) Error
~ end.
\normalfont%
\caption{Expansion of argument expression and left member returns.}
\end{figure}

Assume we want to expand an array into variables. Single cell indexing can be
resolved to a single variable when the index is a constant. Otherwise we do not
support it. The exception is when the index is a for loop variable, in which
case at this compilation step it is a constant because loop unrolling has
already been performed.
Currently only this part is implemented in Jasmin.

Whole array access can be resolved either by introducing a real array on which
the operation is performed, or when the operation can be unrolled by unrolling
it and using the method for single cell indexing. We won't introduce
intermediate arrays because we do not want to incur hidden costs. If the user
wants to introduce an intermediate array they can and the resulting operation
can be unrolled.

Finally array slicing would only be supported when the parameters of the slice
are constant. In this case the slice is a new array and the variable it is
replaced by is a slice with the same parameters of the variables by which the
original array would be replaced by.

\smallskip

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
Fixpoint expand\_i fexpd m i :=
~ match i with
~ | Cassgn x e \(\Rightarrow\)
~   match expand\_lv m x, expand\_e m e     with
~   | Ok (inl x)       , Ok (inl e)       \(\Rightarrow\) Ok [:: Cassgn x e ]
~   | Ok (inr xs)      , Ok (inr es)      \(\Rightarrow\) map2 Cassgn xs es
~   | Ok (inl x)       , Ok (inr es)      \(\Rightarrow\)
~     Let xs := expand\_lv\_n m x (size es) in map2 Cassgn xs es
~   | Ok (inl xs)      , Ok (inr e)       \(\Rightarrow\)
~     Let xs := expand\_e\_n  m x (size xs) in map2 Cassgn xs es
~   | \_                                   \(\Rightarrow\) Error
~   end
~ | Ccall xs fn es \(\Rightarrow\)
~   if get fexpd fn is Some (expargs, expret) then
~     Let xs := mapM2 (expand\_ret m) expargs xs in
~     Let es := mapM2 (expand\_arg m) expret  es in
~     Ok [:: Ccall (flatten xs) fn (flatten es) ]
~   else Error
~ end.
\normalfont%
\caption{Expansion of statements.}
\end{figure}

In practise we could perform these expansions in expressions and left members
as explained using a function returning a list of expressions/left members and
by checking the array is a single value in the recursive cases. The assignment
would then match the left members with the right members. If this fails we have
a register array on one side and a non register array on the other side, so the
unroll could be done by indexing each cell of the shorter list as long if it is
a variable or a sub array, or duplicating the discard. The other cases would
duplicate an operation so they instead would fail to compile to not introduce
hidden costs.

\medskip

There is another kind of expansion when a function takes some register arrays as
parameters. In this case we instead take as many register variables as necessary
instead of the array. That transformation is only wanted when the function is
not exported to the other programs because we do not want to make such changes
unbeknown to the user. Jasmin could either warn the user or fail to compile the
program as we implemented it.
Only array expansion for internal functions will be implemented in this article
even though our changes enables the other unimplemented expansion above.
In practise the expansion of all function signatures needs to be performed first
to know which argument should be expanded when a function is called.


\section{Semantics aspect of array expansion}\label{sec:semantics}

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
Variant value :=
~ | Varr s n : array s n \(\rightarrow\) value
~ | Vword s  : word  s   \(\rightarrow\) value.

Definition sem\_t t :=
~ match t with
~ | Arr s n \(\Rightarrow\) array s n
~ | Word s  \(\Rightarrow\) word  s
~ end.
\normalfont%
\caption{Simplified value types.}\label{fig:val}
\end{figure}

\subsection{Relevant parts of Jasmin semantics}

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
Definition type\_of\_val v :=
~ match v with
~ | Vword s  \_ \(\Rightarrow\) Word s
~ | Varr s n \_ \(\Rightarrow\) Arr s n
~ end.

Definition to\_arr  n v := if v is Varr s n t then Ok t else Error.

Definition to\_word s v := if v is Vword s  w then Ok w else Error.

Definition to\_val t : sem\_t t \(\rightarrow\) value :=
~ match t return sem\_t t \(\rightarrow\) value with
~ | Arr s n \(\Rightarrow\) Varr s n
~ | Word s  \(\Rightarrow\) Vword s
~ end.
\normalfont%
\caption{Utilitary functions on \texttt{value} and \texttt{sem\_t}.}
\end{figure}

In this section, the relevant parts of Jasmin semantics are described.

Jasmin values can be words and partially defined arrays of words. Variables value
are stored using the dependant type \texttt{sem\_t} as defined in Figure
\ref{fig:val} in order to keep the invariant
\texttt{m.[x] = Ok v\(\implies\)type\_of\_val v = v\_ty x}.

\medskip

\begin{figure}[!t]
\obeylines\obeyspaces\ttfamily%
Fixpoint sem\_pexpr vm e :=
~ match e with
~ | Pconst s z \(\Rightarrow\) Ok (Vword s (wrepr s z))
~ | Parr\_init s n \(\Rightarrow\) Ok (Varr s n (empty s n))
~ | Pvar v \(\Rightarrow\) vm.[v]
~ | Pget aa x e \(\Rightarrow\)
~   Let Varr s n t := vm.[x] in
~   Let i := sem\_pexpr vm e >{}>= to\_int in
~   Let w := get aa t i in
~   Ok (Vword s w)
~ | Psub aa len x e \(\Rightarrow\)
~   Let Varr s n t := vm.[x] in
~   Let i := sem\_pexpr vm e >{}>= to\_int in
~   Let t' := get\_sub aa len t i in
~   Ok (Varr s len t')
~ end.

Definition write\_lval l v vm :=
~ match l with
~ | Lnone \(\Rightarrow\) Ok s
~ | Lvar x \(\Rightarrow\) vm.[x \(\leftarrow\) v]
~ | Laset aa x i \(\Rightarrow\)
~   Let Varr s n t := vm.[x] in
~   Let i := sem\_pexpr vm i >{}>= to\_int in
~   Let w := to\_word s v in
~   Let t := set t aa i w in
~   vm.[x \(\leftarrow\) to\_val (Arr s n) t]
~ | Lasub aa len x i \(\Rightarrow\)
~   Let Varr s n t := vm.[x] in
~   Let i := sem\_pexpr vm i >{}>= to\_int in
~   Let t' := to\_arr s len v in 
~   Let t := set\_sub n aa len t i t' in
~   vm.[x \(\leftarrow\) to\_val (Arr s len) t]
~ end.
\normalfont%
\caption{Top: function evaluating expression e in context vm; %
Bottom: function modifying context s with value v according to left member l.}
\end{figure}

Semantics of expressions is a partial function taking a context and an
expression and returning a value.
The semantic of constant is the constant word value. The semantic of empty array
is the array value where no indicies are defined. The sematic of a variable is
the value associated to that variable in the context if there is one. The
semantic of indexing an array variable is the word value associated to the word
at the index given by the semantic of the index expression --if its semantic
is defined-- of the array associated to the variable in the context if it is an
array and the value at that index for the given array access scheme is defined
and in bounds. The semantic of slicing an array variable is the array value
obtained by slicing the array associated to the variable in the context --if it
is an array-- using the array access scheme and length given and the semantics
of the starting offset expression if its semantic is defined and the slice is in
bounds.

\smallskip

Semantics of left members is a partial function taking a left member, a value
and a context, and returns a context.
The semantic of the discard is the unchanged context. The semantic of a variable
is the context where the variable is now associated to the given value if its
type is the same as the variable. The semantic of indexing an array variable is
the context where the array associated to the variable --if it is an array-- has
its cell given by the array access scheme and the semantic of the index
expression --if its semantic is defined and in bounds-- is is now associated to
the given value if its type is the correct word type. The semantic of slicing an
array variable is the context where each cell of the array variable --if it is
an array-- intersecting with the slice obtained using the array access scheme
and length given and the semantic of the starting offset expression --if its
semantic is defined and the slice is in bounds-- is now associated to the right
word of the given value if it is an array of the right length.

\medskip

\begin{figure}[t]
\ttfamily
sem\_call P :
\begin{center}
\begin{tabular}{c}
get\_func P fn = Some f \\
fold2 (\(\lambda\)x v, vm.[x \(\leftarrow\) v]) (f\_args f) vargs empty = Ok vm1 \\
sem P vm1 (f\_body f) vm2 \\
mapM (\(\lambda\)x, vm2.[x]) (f\_ret f) = Ok vres
\\\hline
sem\_call P fn vargs vres
\end{tabular}
\end{center}

sem P :
\begin{center}
\begin{tabular}{c}
\\\hline
sem P vm [::] vm
\end{tabular} Eskip\quad
\begin{tabular}{c}
sem\_i P vm1 i vm2\quad
sem P vm2 l vm3
\\\hline
sem P vm1 (i::l) vm3
\end{tabular} Eseq
\end{center}

sem\_i P :
\begin{center}
\begin{tabular}{c}
sem\_pexpr vm1 e = Ok v\quad
write\_lval x v vm1 = Ok vm2
\\\hline
sem\_i P vm1 (Cassgn x e) vm2
\end{tabular} Eassgn

~

\begin{tabular}{c}
mapM (sem\_pexpr vm1) args = Ok vargs \\
sem\_call P f vargs vres \\
fold2 write\_lval xs vres vm1 = Ok vm2
\\\hline
sem\_i P vm1 (Ccall xs f args) vm2.
\end{tabular} \raisebox{-\baselineskip}{Ecall}
\end{center}
\normalfont%
\caption{Simplified inductive big step semantics rules.}
\end{figure}

The semantics of Jasmin functions and instructions in a program are big step
inductive predicates. The former relates functions, their arguments and returned
values, the latter relates two contexts and an instruction.

The semantics of a function call in a program is a predicate relating a function
identifier, its arguments values and its returned values. The only rule is made
of four conditions: the identifier is bound to of functions of the program, the
function bound to this identifier takes as many parameters as the argument given
and binding the arguments to the parameters on an empty context gives a valid
context, the semantics of the accumulated statements relate this valid context
to another context, and in this latter context the value associated to the
return values of the function correspond to the return values of the jugement.

\smallskip

The semantics of a statement relates an instruction, an initial context and the
context after executing this statement. The two rules relevant to us are the
rules for assignment and function call, giving a semantics to the corresponding
statements. The rule for assignments relates an initial context and the assignment
statement with the semantics of the left member of the assignment where the
value is the semantics of the expression of the assignment. The rule for a
function call relates the function call satement and an initial context to the
accumulated semantics of all the left members starting from the initial context
on the returned values of the semantics of the function call of the function
identifier and the arguments obtained by the semantics of the argument
expressions in the initial context.


\subsection{Semantic implications of array expansion}

In this section the syntactic and semantics changes of all the cases for array
expansion are described, and the semantic implication of such changes are
discussed.

\begin{figure}[tp]
\obeylines\obeyspaces\ttfamily%
Definition eval\_array t i :=
~ rmap Vword (WArray.get AAscale t i).

Definition expand\_v expd v :=
~ match expd with
~ | true  \(\Rightarrow\) if v is Arr s n t then mapM (eval\_array t) (iota 0 n) else Error
~ | false \(\Rightarrow\) Ok [:: v ]
~ end.

Definition eq\_alloc m vm1 vm2 : Prop :=
~ \(\forall\)x, match get m x with
~ | Some vx \(\Rightarrow\) \(\forall\)i vi,
~   get vx i = Some vi \(\Longrightarrow\) Let Varr s n t := vm1.[x] in eval\_array t i = vm2.[vi]
~ | None \(\Rightarrow\) vm1.[x] = vm2.[x]
~ end.

Lemma expand\_ePl m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)e1 e2, expand\_e m e1 = Ok (inl e2) \(\Longrightarrow\)
~ \(\forall\)v, sem\_pexpr vm1 e1 = Ok v \(\Longrightarrow\) sem\_pexpr vm2 e2 = Ok v.

Lemma expand\_ePr m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)e1 es2, expand\_e m e1 = Ok (inr es2) \(\Longrightarrow\)
~ \(\forall\)v, sem\_pexpr vm1 e1 = Ok v \(\Longrightarrow\)
~ \(\exists\)vs, expand\_v true v = Ok vs \(\wedge\) mapM2 sem\_pexpr vm2 es2 = Ok vs.

Lemma expand\_lvPl m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)x1 x2, expand\_lv m x1 = Ok (inl x2) \(\Longrightarrow\)
~ \(\forall\)v vm1', write\_lval x1 v vm1 = Ok vm1' \(\Longrightarrow\)
~ \(\exists\)vm2', write\_lval x2 v vm2 = Ok vm2' \(\wedge\) eq\_alloc m vm1' vm2'.

Lemma expand\_lvPr m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)x1 xs2, expand\_lv m x1 = Ok (inr xs2) \(\Longrightarrow\)
~ \(\forall\)v vm1', write\_lval x1 v vm1 = Ok vm1' \(\Longrightarrow\)
~ \(\exists\)vs, expand\_v true v = Ok vs \(\wedge\)
~   \(\exists\)vm2', fold2 write\_lval xs2 vs vm2 = Ok vm2' \(\wedge\) eq\_alloc m vm1' vm2'.

Lemma expand\_funcP P1 P2 fexpd fn vargs vret :=
~ sem\_call P1 fn vargs vret \(\Longrightarrow\)
~ \(\forall\)expdin expdout, get fexpd fn = Some (expargs, expret) \(\Longrightarrow\)
~ \(\forall\)vargs', mapM (expand\_v \(\circ\) is\_some) expargs vargs = Ok vargs' \(\Longrightarrow\)
~ \(\exists\)vret', mapM (expand\_v \(\circ\) is\_some) expret  vret  = Ok vret'  \(\wedge\)
~   sem\_call P2 fn (flatten vargs') (flatten vres').

Lemma expand\_iP P1 P2 fexpd m vm1 vm2 :=
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)i1 vm1', sem\_i P1 vm1 i1 vm1' \(\Longrightarrow\)
~ \(\forall\)is2, expand\_i fexpd m i1 = Ok is2 \(\Longrightarrow\)
~ \(\exists\)vm2', sem P2 vm2 is2 vm2' \(\wedge\) eq\_alloc m vm1' vm2'.
\normalfont%
\caption{TODO}
\end{figure}

% Présenter tous les cas sémantiques simples sans necessiter de 1->many qui
% fonctionnent d'array expansion puis tous les cas 1->many qui du coup ne
% fonctionnent pas
% Pget when expanded and not expanded
% Laset when expanded and not expanded
% Pvar Lnone Lvar Psub Lasub currently, then what they should do, how to handle
% a list in recursive expansion
% Cassgn
% MkFun
% Ccall
% Présenter la problématique introduite par cette transformation qui la rendrait
% improuvable puis les pistes de modifications.


\section{}
% Présentation des modifications de la sémantique au niveau des fonctions ainsi
% que des varmap, avec les propriétés importantes et l'élimination des types
% dépendants pour justifier les choix. Et de la transformation effectuée.

\section{Conclusion}
% Présentation du travail restant dans le stage ainsi que potentiellement après
% le stage: FIXER LES PREUVES

\end{document}
