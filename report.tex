\documentclass{article}

%\usepackage{xunicode}
\usepackage[T1]{fontenc}
%\usepackage{fontspec}
\usepackage{geometry}
\usepackage[english]{babel}
%\usepackage{polyglossia}
%\setmainlanguage{english}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{unicode-math}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}
\setlist{nosep,leftmargin=*}
\frenchspacing

\newcommand\setR{\mathbb{R}}
\newcommand\setZ{\mathbb{Z}}
\newcommand\setN{\mathbb{N}}

\title{Improving array expansion in Jasmin compiler}
\author{Quentin \textsc{Corradi}}
\setlength{\parindent}{0pt}

% TODO: biblio (Jasmin articles, array contraction)

\begin{document}

\maketitle

\section{Introduction}

Jasmin is a compiler and a language designed for writing high-assurance and
high-speed cryptography primitives. The semantics is formally defined to allow
rigorous reasoning about program behaviors.
The Jasmin language is close to assembly, the main differences lie in:
\begin{itemize}
\item Jasmin abstracts numerical operations common in cryptography
\item Jasmin provides variables and performs variable allocation in registers
\item Jasmin supports arrays
\item Jasmin provides common control flow statements
\item Jasmin provides functions with support for C calling convention if needed
\item Jasmin presents assembly instruction with a functional style to avoid
hidden side effects
\end{itemize}

In Jasmin there are two kind of variables, the stack allocated ones and the
register allocated ones. The user has to tell the compiler the kind of every
variables. This also holds true for arrays. However on most processors on which
people run cryptographic primitives and software, there is no hardware support
for indexing registers with a value, all registers need to be known at
compilation. In Jasmin a compilation step does it.

\medskip

In most programming languages, arrays are an abstraction for handling memory
using integers. It abstracts contiguous memory into a partial map from integers
to memory cells in order to hide arithmetic on pointers. This abstraction could
also be thought as a partial map from integers to variables, that is any array
\(t\) of size \(N\) could be replaced by \(N\) variables
\(t_0, \dots, t_{N - 1}\) and a pair of functions
\((\mathit{get}, \mathit{set})\) such that \(\mathit{get} : k \mapsto t_k\) and
\(\mathit{set}\;k\;x\) sets \(t_k\) to \(x\).

This way of thinking about arrays allows us to eliminate Jasmin register arrays
by replacing them by variables. This compilation step is called array expansion
and is not a standard compilation step. In the following array expansion will
also refer to the action of eliminating arrays by replacing them with the
appropriate amount of variables.

\medskip

In this article we try to extend the array expansion step the Jasmin compiler
already performs. In particular we implemeted array expansion in function
signature and function calls, and we studied how more array expansion could be
performed in particular for assignments informed by how the expansion of whole
arrays in function call works.

% TODO: related word

\medskip

This article is organised as follows:
In Section \ref{sec:syntax} the relevant parts of Jasmin syntax trees are
presented then the syntactic side of array expansion is explained more in-depth
for our intended use in Jasmin.
In Section \ref{sec:semantics} the relevant parts of Jasmin semantics are
presented then the semantic side of array expansion is explored.
In Section \ref{sec:perch} we describe and justify a change we made to the core
of Jasmin semantics and the consequent changes we had to make in order to
accomodate it and fix the correctness theorems.

\begin{figure}[!b]
\obeylines\obeyspaces\ttfamily%
type wsize = \(\{ 2^i \mid i \in \setN \}\)

type ty =
| Word of wsize
| Arr  of wsize \(\times\;\setN\)

type v\_kind =
| Stack
| Reg

type var = \{
~ v\_id   : uid;
~ v\_kind : v\_kind;
~ v\_ty   : ty;
\}

type expr =
| Pconst    of wsize \(\times\;\setZ\)
| Parr\_init of wsize \(\times\;\setN\)
| Pvar      of var
| Pget      of var \(\times\) expr
| Psub      of \(\setN\;\times\) var \(\times\) expr

type lval =
| Lnone
| Lvar  of var
| Laset of var \(\times\) expr
| Lasub of \(\setN\;\times\) var \(\times\) expr

type instr =
| Cassgn of lval \(\times\) expr
| Ccall  of lval list \(\times\) uid \(\times\) expr list

type call\_conv =
| Export
| Subroutine

type func = \{
~ f\_name : uid;
~ f\_args : var list;
~ f\_body : instr list;
~ f\_ret  : var list;
~ f\_cc   : call\_conv;
\}

type prog = func list
\normalfont%
\caption{Stripped and simplified version of Jasmin programs' AST type.}\label{fig:types}
\end{figure}


\section{Array expansion compiler pass}\label{sec:syntax}

\subsection{Introduction to relevant parts of Jasmin syntax}

In this section, the relevant parts of Jasmin programs' AST type is described.
The irrelevant parts, if mentioned, will not be expanded upon. Most of the types
are described in Figure \ref{fig:types} using a mix of a mathematical and
OCaml-like syntax.

A Jasmin progam is a list of functions. A function is made of its name, a unique
identifier; its parameters, a list of variables; its body, a list of
instructions; its returned variables, a list of variables; and its kind. The
kind of a function can be ``exported to the outside'', in which case the
function must follow some calling convention, or internal (subroutine).

\smallskip

An instruction can be an assignment or a function call. Other instructions
include assembly instructions and control flow instructions, however they are
not relevant to our work.

An assignment is made of an lvalue and an expression. A function call is
made of the called function identifier, a list of lvalues matching the
function returned variables list on length, and a list of expressions matching
the function parameters list on length.

Function arguments and return variables, lvalues and expressions refer to
variables. A variable is made of an identifier, a type and a kind. In the AST a
variable doesn't have to be declared in order to be used. Across a function
body, parameters and returned variables, all variables featuring the same
identifier and type are considered to be the same. A variable kind is a
constraint on where the compiler can store the value, it is either on the stack
or in a register.

\smallskip

An lvalue indicates where to store a value, it is either a variable
(\texttt{Lvar} constructor), a cell of an array variable (\texttt{Laset}), a
slice of an array variable (\texttt{Lasub}) or nowhere (\texttt{Lnone})
indicating the value will not be used and can be discarded as soon as possible.

An expression can be a constant word (\texttt{Pconst}), an empty array with no
initialised cell (\texttt{Parr\_init}), a variable (\texttt{Pvar}), a cell of an
array variable (\texttt{Pget}) or a slice of an array variable (\texttt{Psub}).
Operations like the addition of two expressions are also expressions.

Single array cells are indexed by expressions. Slice are contiguous sections of
arrays. The section is described using its length and offset from the begining
of the array. The length is a non-negative number and the offset an expression.

\smallskip

Arrays and words are two Jasmin types. A word is two to a non-negative power,
representing the size of the word in bytes. An array is a partial map from
non-negative numbers to words of some size.

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let rec expand\_e m = function
~ | Pvar x \(\rightarrow\) if expand\_var m x is Some vx
~   then Ok (inr [:: Pvar v | v \(\leftarrow\) vx ]) else Ok (inl (Pvar x))
~ | Pget x e \(\rightarrow\) if expand\_var m x is Some vx then
~     if e is Pconst \_ z then if get vx z is Some v then Ok (inl (Pvar v))
~     else Error else Error
~   else Let inl e = expand\_e m e in Ok (inl (Pget x e))
~ | Psub len x e \(\rightarrow\) if expand\_var m x is Some vx then
~     if e is Pconst \_ z then Ok (inr [:: Pvar v | v \(\leftarrow\) take len (drop z vx) ])
~     else Error
~   else Let inl e = expand\_e m e in Ok (inl (Psub ws len x e))
~ | e \(\rightarrow\) Ok (inl e)

let expand\_lv m = function
~ | Lvar x \(\rightarrow\) if expand\_var m x is Some vx
~   then Ok (inr [:: Lvar v | v \(\leftarrow\) vx ]) else Ok (inl (Lvar x))
~ | Laset x e \(\rightarrow\) if expand\_var m x is Some vx then
~     if e is Pconst \_ z then if get vx z is Some v then Ok (inl (Lvar v))
~     else Error else Error
~   else Let inl e = expand\_e m e in Ok (inl (Laset x e))
~ | Lasub len x e \(\rightarrow\) if expand\_var m x is Some vx then
~     if e is Pconst \_ z then Ok (inr [:: Lvar v | v \(\leftarrow\) take len (drop z vx) ])
~     else Error
~   else Let inl e = expand\_e m e in Ok (inl (Lasub len x e))
~ | x \(\rightarrow\) Ok (inl x)
\normalfont%
\caption{Expansion of expressions and lvalues.}\label{fig:fullexp}
\end{figure}

\subsection{Array expansion in Jasmin compiler}

A variable of type array and kind register means an array of registers, but in
most common processors on which cryptographic primitives are run there is no
hardware support for indexing registers with a register. Therefore we need to
eliminate them in some compilation step; this is what the array expansion step
does in the Jasmin compiler. Other kind of arrays are not expanded --even though
we could try to expand them-- because there is hardware support for indexing
memory with a register and so we consider users know what they want.

In order to expand an array we have to replace all store and load operations
performed on this array and modify function signature it appears in. The load
and store operations (resp. in expressions and lvalues) come in three kinds:
single cell indexing, array slicing and whole array access.

\smallskip

Assume we have a map associating each array to the list of variables it is
expanded to (called \texttt{m} in the following figures; as all array length are
known in Jasmin it is just a matter of generating enough fresh names).

\medskip

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let expand\_e\_n m n = function
~ | Pvar x       \(\rightarrow\) if v\_ty x is Arr \_ \_
~   then Ok [:: Pget v (Pconst U64 i) | 0 \(\leq\) i \(<\) n ] else Error
~ | Psub len x e \(\rightarrow\) Ok [:: Pget v (Padd e (Pconst U64 i)) | 0 \(\leq\) i \(<\) n ]
~ | \_ \(\rightarrow\) Error
 
let expand\_lv\_n m n = function
~ | Lnone         \(\rightarrow\) Ok [:: Lnone | 0 \(\leq\) i \(<\) n ]
~ | Lvar x        \(\rightarrow\) if v\_ty x is Arr \_ \_
~   then Ok [:: Laset x (Pconst U64 i) | 0 \(\leq\) i \(<\) n ] else Error
~ | Lasub len x e \(\rightarrow\) Ok [:: Laset x (Padd e (Pconst U64 i)) | 0 \(\leq\) i \(<\) n ]
~ | \_             \(\rightarrow\) Error
\normalfont%
\caption{Expansion for unrolling expressions and lvalues.}\label{fig:unrexp}
\end{figure}

The array expansion for expressions and lvalues are depicted in Figure
\ref{fig:fullexp} using a pseudo OCaml-like syntax for convenience.
In this figure and all the following, \texttt{Let} \textit{pat} \texttt{=}
\textit{e1} \texttt{in} \texttt{e2} is a shorthand for matching the result of
\textit{e1} against \texttt{Ok} \textit{pat} and \texttt{Error}; in the former
case the relevant variables of \textit{pat} are bound and \textit{e2} is
evaluated, in the latter case the expression evaluates to \texttt{Error}.

The figure doesn't describe actual implemented code because expansion of
variables and subarrays for assignments is performed in a previous compilation
step\footnote{Prior to our work, single cell access for lvalues and expression
in assignments was implmented in the array expansion step and variable expansion
was implemented in a previous compilation step}, but they could all be
implemented in one compiler step as the code required to expand expressions and
lvalues for function calls and assignment only differs slightly as will be shown
further in this section.

\smallskip

Single cell indexing (\texttt{Pget} and \texttt{Laget}) can be expanded to a
single variable (\texttt{Pvar} and \texttt{Lvar}) when the index is a constant.
Otherwise it is not supported. When the index is a for loop variable in the
original program, the loop unrolling and constant propagation steps which come
before the array expansion step have already transformed the indexes into
constants, so it also falls under the constant case.

Array slices (\texttt{Psub} and \texttt{Lasub}) are expanded by acceding to
the relevant slice of variables replacing the array provided the offset
parameter is a constant. The operation performed on this slice will then require
an unrolling.

Finally whole array accesses (\texttt{Pvar} and \texttt{Lvar}) are equivalent to
slices of arrays with no offset and same length as the base array on which they
are performed. They are replaced by all the variables the array is to be
replaced with.

\smallskip

In order to perform the unrolling we need to know whether an expansion was
performed in expressions and lvalues because an array may have been expanded in
one but not in the other, and only looking at the length of the expanded
expressions and lvalues isn't sufficient as arrays can be of length one.

For instance when expanding an assignment between a single cell register array
and a single cell stack array, the register array will be expanded to a list of
one expression or lvalue (depending on which side of the assignment it is),
which by the length alone doesn't tell whether it was expanded or not, and we
should know that because in one case nothing is done and in the other the
assignment is unrolled, that is the array on the other side is replaced with an
access to its only cell.

The expansion for unrolling expressions and lvalues (no array expansion
performed) is illustrated in Figure \ref{fig:unrexp} with the functions
\texttt{expand\_e\_n} and \texttt{expand\_lv\_n} to expand expressions and
lvalues when the other side expansion is of length \texttt{n}.

The expansions performed for unrolling array variables and slices consist in
accessing the relevant cells. The only other case where an unrolling makes sense
is the \texttt{Lnone} lvalue, which is the only one requiring a length to know
how many times it should be duplicated.

\medskip

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let expand\_fvar m v =
~ if expand\_var m v is Some vx then (Some (size vx), vx) else (None, [:: v ])

let expand\_fsig m fd =
~ let \{| f\_cc; f\_name; f\_args; f\_body; f\_ret |\} = fd in
~ if f\_cc = Export then (fd, None) else
~ let (args, expargs) = split [:: expand\_fvar m v | v \(\leftarrow\) f\_args ] in
~ let (ret,  expret)  = split [:: expand\_fvar m v | v \(\leftarrow\) f\_ret  ] in
~ (\{| f\_cc; f\_name; f\_args := flatten args; f\_body; f\_ret := flatten ret |\},
~   Some (expargs, expret))

let expand\_arg m ex e =
~ match ex, expand\_e m e with
~ | Some \_, Ok (inr es)  \(\rightarrow\) Ok es
~ | Some n, Ok (inl e)   \(\rightarrow\) expand\_e\_n m n e
~ | None  , Ok (inl e)   \(\rightarrow\) Ok [:: e ]
~ | \_                    \(\rightarrow\) Error

let expand\_ret m ex x =
~ match ex, expand\_lv m x with
~ | Some \_, Ok (inr xs)   \(\rightarrow\) Ok xs
~ | Some n, Ok (inl x)    \(\rightarrow\) expand\_lv\_n m n x
~ | None  , Ok (inl x)    \(\rightarrow\) Ok [:: x ]
~ | \_                     \(\rightarrow\) Error
\normalfont%
\caption{Expansion of signatures, argument expressions and returned values lvalues.}\label{fig:sigexp}
\end{figure}

Array expansion for function signatures and argument expressions and
returned values lvalues in function calls are depicted in Figure
\ref{fig:sigexp}.

The expansion of an array in function signature is simply a matter of replacing
it with the variables it is expanded to. A slight subtelty however is that like
expansion for expressions and lvalues we need to know which variables were
expanded in order to expand (sometimes without actual array expansion as
illustrated in \texttt{expand\_arg} and \texttt{expand\_ret}) arguments and
return assignments accordingly.

\smallskip

The expansion in function signature is only wanted when the function is not
exported to other programs because we do not want to make such changes unbeknown
to the user. Two solution satisfy this constraint\footnote{If register array
were allowed in exported functions by the typechecker}: warning the user or
failing to compile. As the global correction theorem only mentions exported
functions it would have to be complexified in order to reflect signature
expansion if we chose the former solution so we chose the latter.

\medskip

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let rec expand\_i fexpd m = function
~ | Cassgn x e \(\rightarrow\)
~   match expand\_lv m x, expand\_e m e    with
~   | Ok (inl x)       , Ok (inl e)      \(\rightarrow\) Ok [:: Cassgn x e ]
~   | Ok (inr xs)      , Ok (inr es)     \(\rightarrow\) [:: Cassgn x e | x \(\leftarrow\) xs, e \(\leftarrow\) es ]
~   | Ok (inl x)       , Ok (inr es)     \(\rightarrow\)
~     Let xs = expand\_lv\_n m x (size es) in [:: Cassgn x e | x \(\leftarrow\) xs, e \(\leftarrow\) es ]
~   | Ok (inl xs)      , Ok (inr e)      \(\rightarrow\)
~     Let es = expand\_e\_n  m x (size xs) in [:: Cassgn x e | x \(\leftarrow\) xs, e \(\leftarrow\) es ]
~   | \_                                  \(\rightarrow\) Error
~ | Ccall xs fn es \(\rightarrow\)
~   if get fexpd fn is Some (expargs, expret) then
~     Let xs = [:: expand\_ret m xp x | xp \(\leftarrow\) expargs, x \(\leftarrow\) xs ] in
~     Let es = [:: expand\_arg m xp e | xp \(\leftarrow\) expret , e \(\leftarrow\) es ] in
~     Ok [:: Ccall (flatten xs) fn (flatten es) ]
~   else
~     Let xs = [:: Let inl x' = expand\_lv x in x' | x \(\leftarrow\) xs ] in
~     Let es = [:: Let inl e' = expand\_e e  in e' | e \(\leftarrow\) es ] in
~     Ok [:: Ccall xs fn es ]
\normalfont%
\caption{Expansion of instructions.}\label{fig:insexp}
\end{figure}

Expansion of instructions is illustrated in Figure \ref{fig:insexp}. As
described previously assignment are expanded by expanding each side of the
assignment and unrolling if necessary and function calls are expanded using
informating gathered while expanding the signature, which means signature
expansion needs to be performed first on every function before expanding the
body of any function.

\section{Semantics aspect of array expansion}\label{sec:semantics}

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
type value =
| Varr s n of array s n
| Vword s  of word  s

type sem\_t = function
| Arr s n \(\rightarrow\) array s n
| Word s  \(\rightarrow\) word  s
\normalfont%
\caption{Simplified value types.}\label{fig:oldval}
\end{figure}

\subsection{Relevant parts of Jasmin semantics}

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let type\_of\_val = function
~ | Vword s  \_ \(\rightarrow\) Word s
~ | Varr s n \_ \(\rightarrow\) Arr s n

let to\_arr  n v = if v is Varr s n t then Ok t else Error.

let to\_word s v = if v is Vword s  w then Ok w else Error.

let to\_val : sem\_t t \(\rightarrow\) value = function
~ | Arr s n \(\rightarrow\) Varr s n
~ | Word s  \(\rightarrow\) Vword s
\normalfont%
\caption{Utilitary functions on \texttt{value} and \texttt{sem\_t}.}\label{fig:oldvfun}
\end{figure}

In this section, the relevant parts of Jasmin semantics are described. None of
it is part of our contribution but it is necessary in order to understand
the main properties we have to prove for the compiler correctness theorem.

% TODO: from HERE

Jasmin values can be words and partially defined arrays of words. Variables value
are stored using the dependant type \texttt{sem\_t} as defined in Figure
\ref{fig:oldval} in order to keep the invariant
\texttt{m.[x] = Ok v\(\implies\)type\_of\_val v = v\_ty x}.

\medskip

\begin{figure}[!t]
\obeylines\obeyspaces\ttfamily%
let rec sem\_pexpr vm = function
~ | Pconst s z \(\rightarrow\) Ok (Vword s (wrepr s z))
~ | Parr\_init s n \(\rightarrow\) Ok (Varr s n (empty s n))
~ | Pvar v \(\rightarrow\) vm.[v]
~ | Pget x e \(\rightarrow\)
~   Let Varr s n t = vm.[x] in
~   Let i = sem\_pexpr vm e >{}>= to\_int in
~   Let w = array\_get t i in
~   Ok (Vword s w)
~ | Psub len x e \(\rightarrow\)
~   Let Varr s n t = vm.[x] in
~   Let i = sem\_pexpr vm e >{}>= to\_int in
~   Let t' = array\_get\_sub len t i in
~   Ok (Varr s len t')

let write\_lval l v vm =
~ match l with
~ | Lnone \(\rightarrow\) Ok s
~ | Lvar x \(\rightarrow\) vm.[x \(\leftarrow\) v]
~ | Laset x i \(\rightarrow\)
~   Let Varr s n t = vm.[x] in
~   Let i = sem\_pexpr vm i >{}>= to\_int in
~   Let w = to\_word s v in
~   Let t = set t i w in
~   vm.[x \(\leftarrow\) to\_val (Arr s n) t]
~ | Lasub len x i \(\rightarrow\)
~   Let Varr s n t = vm.[x] in
~   Let i = sem\_pexpr vm i >{}>= to\_int in
~   Let t' = to\_arr s len v in 
~   Let t = set\_sub n len t i t' in
~   vm.[x \(\leftarrow\) to\_val (Arr s len) t]
~ end.
\normalfont%
\caption{Top: function evaluating expression e in context vm; %
Bottom: function modifying context s with value v according to lvalue l.}
\end{figure}

Semantics of expressions is a partial function taking a context and an
expression and returning a value.
The semantic of constant is the constant word value. The semantic of empty array
is the array value where no indicies are defined. The sematic of a variable is
the value associated to that variable in the context if there is one. The
semantic of indexing an array variable is the word value associated to the word
at the index given by the semantic of the index expression --if its semantic
is defined-- of the array associated to the variable in the context if it is an
array and the value at that index for the given array access scheme is defined
and in bounds. The semantic of slicing an array variable is the array value
obtained by slicing the array associated to the variable in the context --if it
is an array-- using the array access scheme and length given and the semantics
of the starting offset expression if its semantic is defined and the slice is in
bounds.

\smallskip

Semantics of lvalues is a partial function taking an lvalue, a value
and a context, and returns a context.
The semantic of the discard is the unchanged context. The semantic of a variable
is the context where the variable is now associated to the given value if its
type is the same as the variable. The semantic of indexing an array variable is
the context where the array associated to the variable --if it is an array-- has
its cell given by the array access scheme and the semantic of the index
expression --if its semantic is defined and in bounds-- is is now associated to
the given value if its type is the correct word type. The semantic of slicing an
array variable is the context where each cell of the array variable --if it is
an array-- intersecting with the slice obtained using the array access scheme
and length given and the semantic of the starting offset expression --if its
semantic is defined and the slice is in bounds-- is now associated to the right
word of the given value if it is an array of the right length.

\medskip

\begin{figure}[t]
\ttfamily
sem\_call P :
\begin{center}
\begin{tabular}{c}
get\_func P fn = Some f \\
fold2 (\(\lambda\)x v, vm.[x \(\leftarrow\) v]) (f\_args f) vargs empty = Ok vm1 \\
sem P vm1 (f\_body f) vm2 \\
mapM (\(\lambda\)x, vm2.[x]) (f\_ret f) = Ok vres
\\\hline
sem\_call P fn vargs vres
\end{tabular}
\end{center}

sem P :
\begin{center}
\begin{tabular}{c}
\\\hline
sem P vm [::] vm
\end{tabular} Eskip\quad
\begin{tabular}{c}
sem\_i P vm1 i vm2\quad
sem P vm2 l vm3
\\\hline
sem P vm1 (i::l) vm3
\end{tabular} Eseq
\end{center}

sem\_i P :
\begin{center}
\begin{tabular}{c}
sem\_pexpr vm1 e = Ok v\quad
write\_lval x v vm1 = Ok vm2
\\\hline
sem\_i P vm1 (Cassgn x e) vm2
\end{tabular} Eassgn

~

\begin{tabular}{c}
mapM (sem\_pexpr vm1) args = Ok vargs \\
sem\_call P f vargs vres \\
fold2 write\_lval xs vres vm1 = Ok vm2
\\\hline
sem\_i P vm1 (Ccall xs f args) vm2.
\end{tabular} \raisebox{-\baselineskip}{Ecall}
\end{center}
\normalfont%
\caption{Simplified inductive big step semantics rules.}
\end{figure}

The semantics of Jasmin functions and instructions in a program are big step
inductive predicates. The former relates functions, their arguments and returned
values, the latter relates two contexts and an instruction.

The semantics of a function call in a program is a predicate relating a function
identifier, its arguments values and its returned values. The only rule is made
of four conditions: the identifier is bound to of functions of the program, the
function bound to this identifier takes as many parameters as the argument given
and binding the arguments to the parameters on an empty context gives a valid
context, the semantics of the accumulated instructions relate this valid context
to another context, and in this latter context the value associated to the
return values of the function correspond to the return values of the jugement.

\smallskip

The semantics of an instruction relates an instruction, an initial context and the
context after executing this instruction. The two rules relevant to us are the
rules for assignment and function call, giving a semantics to the corresponding
instructions. The rule for assignments relates an initial context and the assignment
instruction with the semantics of the lvalue of the assignment where the
value is the semantics of the expression of the assignment. The rule for a
function call relates the function call satement and an initial context to the
accumulated semantics of all the lvalues starting from the initial context
on the returned values of the semantics of the function call of the function
identifier and the arguments obtained by the semantics of the argument
expressions in the initial context.


\subsection{Semantic implications of array expansion}

In this section the semantics changes of all the cases for array expansion are
described and their implications are discussed.

\begin{figure}[p]
\obeylines\obeyspaces\ttfamily%
let eval\_array s t i = Let w = array\_get t i in Vword s w.

let expand\_v expd v =
~ match expd with
~ | true  \(\rightarrow\) if v is Arr s n t then [:: eval\_array s t i | i \(\leftarrow\) iota 0 n ]
~   else Error
~ | false \(\rightarrow\) Ok [:: v ]
~ end.

let eq\_alloc m vm1 vm2 : Prop =
~ \(\forall\)x, match get m x with
~ | Some vx \(\rightarrow\) \(\forall\)i vi, get vx i = Some vi \(\Longrightarrow\)
~   (Let Varr s n t = vm1.[x] in eval\_array t i) = vm2.[vi]
~ | None \(\rightarrow\) vm1.[x] = vm2.[x]
~ end.

Lemma expand\_ePl m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)e1 e2, expand\_e m e1 = Ok (inl e2) \(\Longrightarrow\)
~ \(\forall\)v, sem\_pexpr vm1 e1 = Ok v \(\Longrightarrow\) sem\_pexpr vm2 e2 = Ok v.

Lemma expand\_ePr m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)e1 es2, expand\_e m e1 = Ok (inr es2) \(\Longrightarrow\)
~ \(\forall\)v, sem\_pexpr vm1 e1 = Ok v \(\Longrightarrow\)
~ \(\exists\)vs, expand\_v true v = Ok vs \(\wedge\) mapM2 sem\_pexpr vm2 es2 = Ok vs.

Lemma expand\_lvPl m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)x1 x2, expand\_lv m x1 = Ok (inl x2) \(\Longrightarrow\)
~ \(\forall\)v vm1', write\_lval x1 v vm1 = Ok vm1' \(\Longrightarrow\)
~ \(\exists\)vm2', write\_lval x2 v vm2 = Ok vm2' \(\wedge\) eq\_alloc m vm1' vm2'.

Lemma expand\_lvPr m vm1 vm2 :
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)x1 xs2, expand\_lv m x1 = Ok (inr xs2) \(\Longrightarrow\)
~ \(\forall\)v vm1', write\_lval x1 v vm1 = Ok vm1' \(\Longrightarrow\)
~ \(\exists\)vs, expand\_v true v = Ok vs \(\wedge\)
~   \(\exists\)vm2', fold2 write\_lval xs2 vs vm2 = Ok vm2' \(\wedge\) eq\_alloc m vm1' vm2'.

Lemma expand\_funcP P1 P2 fexpd fn vargs vret =
~ sem\_call P1 fn vargs vret \(\Longrightarrow\)
~ \(\forall\)expdin expdout, get fexpd fn = Some (expargs, expret) \(\Longrightarrow\)
~ \(\forall\)vargs', mapM (expand\_v \(\circ\) is\_some) expargs vargs = Ok vargs' \(\Longrightarrow\)
~ \(\exists\)vret',  mapM (expand\_v \(\circ\) is\_some) expret  vret  = Ok vret'  \(\wedge\)
~   sem\_call P2 fn (flatten vargs') (flatten vres').

Lemma expand\_iP P1 P2 fexpd m vm1 vm2 =
~ eq\_alloc m vm1 vm2 \(\Longrightarrow\)
~ \(\forall\)i1 vm1', sem\_i P1 vm1 i1 vm1' \(\Longrightarrow\)
~ \(\forall\)is2, expand\_i fexpd m i1 = Ok is2 \(\Longrightarrow\)
~ \(\exists\)vm2', sem P2 vm2 is2 vm2' \(\wedge\) eq\_alloc m vm1' vm2'.
\normalfont%
\caption{Lemmas relating the semantics before and after array expansion.}
\end{figure}

To express semantics preservation we need a relation on contexts and a relation
between a value and its expansion.

The relation between contexts should relate all expanded array cells to the
target variables, so the relation holds if each variable not expanded is
associated to the same value in both contexts and each cell of each expanded
variable in the source context is associated to the same value as the variable
it is expanded to in the target context.

The relation between a value and its expansion should relates a value to the
list of values where if the value is and array and it should be expanded then
the list is the array cells in order, otherwise the list is the singleton of the
value unchanged.

\medskip

Assume we have a program, its expansion and the expansion information for each
function signature of that program.

The semantics of a function call after array expansion should take the expanded
list of values and return the values of the expanded variables. The semantics is
preserved when if the semantics of a function call in the original program
relates a list of argument to a list of return values then the semantics of the
same function in the expanded program relates the list of expanded arguments and
return values, expansion done according to the expansion information for that
function signature.

The semantics of an instruction after array expansion should be the semantics of
the list of instructions where an assignment is transformed into a list of
instructions and a function call is transformed by changing the argument
expressions and lvalues according to its signature. The semantics is
preserved when the semantics of an instruction and its expansion on related
contexts are related contexts.

\smallskip

The semantics of an expression after array expansion is either the semantics of
the one obtained expression when no expansion was performed or the expression
was a single cell access or the list of the semantics of each expression in the
expansion for array variables and array slices. The semantics is preserved when
expanding the semantics of an expression in a context gives the semantics of
the expanded expression in a related context. Likewise for the semantics of a
lvalues, except we suppose expanded values are related and we should get
related resulting contexts.

\medskip

To prove the semantics preservation, we need to consider that array are actually
partial arrays, so we must be able to expand the whole array without raising an
error, and the target expanded variables have to be associated a value. This is
not limiting in the relation on contexts but it is in the function calls when a
new context is built. To build this new context we evaluate every argument,
including the one we expanded form a partially defined array. It is also
limiting when assigning a arrays because we may not know which cell are defined.

This problem can be solved in several different ways. We could force the array
to be completely initialised, track the initialised cells (which would require
some kind of reduction of expressiveness as otherwise it isn't computable),
store optional words instead of words in the context or allow values to be
undefined. We chose the last solution.

\smallskip

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
type value =
| Varr s n of array s n
| Vword s  of word  s
| Vundef

let type\_of\_val = function
~ | Vundef     \(\rightarrow\) Word 0
~ | Vword s  \_ \(\rightarrow\) Word s
~ | Varr s n \_ \(\rightarrow\) Arr s n
\normalfont%
\caption{New value type.}
\end{figure}

The new value type features the undefined word (arrays are always defined) and
context have been modified to store values of the new \texttt{value} type
instead of the \texttt{sem\_t} dependant type.


\section{Pervasive changes to Jasmin semantics}\label{sec:perch}

In this section the changes to incorporate undefined value are motivated and
described while uncovering some relevant simplifications used in the previous
sections.

There are two main motivations for replacing the dependant type in the contexts.
The first is to include an undefined values, which could be done by an option
type in the dependant type so the second motivation is to simplify the proofs.
Proofs on dependent type tend to be tiresome because every rewriting need to
ensure type are not violated, which in the case of dependant type means ensuring
the parameter given to the dependant type are the same. This need is eliminated
with a value type since all values are of the value type. Removing dependant
types where unnecessary and favoring decidable alternatives is also a design
choice made by SSReflect, a widespread Coq proof library used in Jasmin. The
drawbacks of not using dependant types are that invariants need to be stated and
proved manually, which is actually not that much of a drawback since the
invariants become explicit and the proof needed are usually easy to prove.

\medskip

\begin{figure}
\obeylines\obeyspaces\ttfamily%
type pword s = \{
~ pw\_size  : wsize;
~ pw\_word  : word pw\_size;
~ pw\_proof : pw\_size \(\leq\) s;
\}

type psem\_t = function
| Word s \(\rightarrow\) pword s
| t      \(\rightarrow\) sem\_t t
\normalfont%
\caption{\texttt{psem\_t} dependant type definition.}\label{fig:psemt}
\end{figure}

The old contexts used a dependant type to store the values, this dependant type
was either \texttt{sem\_t} or \texttt{psem\_t}. The latter described in Figure
\ref{fig:psemt} is used to store smaller words into seemingly bigger words for
a compilation step where all registers and words become 64 bits as is available
in a x86 cpu. The old invariant the context maintained using the dependant types
was that the type of the variable corresponded to the type of the value stored
since the type of the value stored was the dependant type aplied to the type of
the variable, which in turn gave the invariant
\texttt{vm.[x] = Ok v \(\Longrightarrow\) type\_of\_val v = v\_ty x} for free.

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let subtype t1 t2 =
~ match t1, t2 with
~ | Word s1, Word s2 \(\rightarrow\) s1 \(\leq\) s2
~ | \_,       \_       \(\rightarrow\) t1 = t2
~ end.

let compat\_type t1 t2 =
~ match t1, t2 with
~ | Word \_, Word \_ \(\rightarrow\) true
~ | \_,      \_      \(\rightarrow\) t1 = t2
~ end.
\normalfont%
\caption{Type relations.}
\end{figure}

The new context store their value in the new \texttt{value} type. To account for
the two cases where we have words of the right size or of a smaller size allowed
the contexts take a type relation as parameter, this type relation is either
equality or subtyping only on words. We need to manually ensure the previous
context invariant is still maintained. However since we have undefined values we
can make the access to a variable in the context never fail, instead like for
the array previously it returns undefined for word variables and an empty array
of the right type for array variable (this is considered the undefined value for
an array) so the new invariant to maintain is
\texttt{vm.[x] \(\neq\) Vundef \(\Longrightarrow\) rel (type\_of\_val vm.[x]) (v\_ty x)}
where \texttt{rel} is the type relation parameter of the context.

\medskip

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let word\_uincl s1 s2 (w1 : word s1) (w2 : word s2) =
~ s1 \(\leq\) s2 \(\wedge\) w1 = zero\_extend s1 w2.

let array\_uincl s1 n1 s2 n2 (a1 : array s1 n1) (a2 : array s2 n2) =
~ n1 = n2 \(\wedge\) \(\forall\)i w,
~   array\_get a1 i = Ok w \(\Longrightarrow\) array\_get a2 i = Ok w.

let value\_uincl v1 v2 =
~ match v1, v2 with
~ | Varr s1 n1 t1, Varr s2 n2 t2 \(\rightarrow\) array\_uincl s1 n1 s2 n2 t1 t2
~ | Vword s1 w1,   Vword s2 w2   \(\rightarrow\) word\_uincl s1 s2 w1 w2
~ | Vundef,        \_             \(\rightarrow\) compat\_type t (type\_of\_val v2)
~ | \_,             \_             \(\rightarrow\) false
~ end.

Lemma value\_uincl\_truncate ty x y x' :
~ value\_uincl x y \(\Longrightarrow\) truncate\_val ty x = Ok x' \(\Longrightarrow\)
~ \(\exists\)y', truncate\_val ty y = Ok y' \(\wedge\) value\_uincl x' y'.

Lemma set\_get vm vm' x v : vm.[x \(\leftarrow\) v] = Ok vm' \(\Longrightarrow\)
~ vm'.[x] = if rel (type\_of\_val v) (v\_ty x) then v else truncate\_val (v\_ty x) v.
\normalfont%
\caption{Core lemma used to prove semantics preservation.}
\end{figure}

The semantics of instructions and function call presented in the previous section
was simplified. In particular because of the step where all stored words become
64 bits, they are truncated to the size they are supposed to be before being
assigned and after being retreived from the context. The truncation function
has to be extended to undefined values. There are several ways to do this
extension, but the truncattion function should still verify two core properties
to most of the proofs of semantic preservation in all compilation steps:
\begin{itemize}
\item If assigning a value to a variable in a context succeds, then the value
  associated to the variable is either the value assigned if the relation of the
  context is satisfied between the type of the value and the type of the
  variable or it is the truncation of the value assigned to the type of the
  variable (if the type of the value is bigger than the type of the variable,
  because it is the only other case where the assignment succeds).
\item If a value is an extension (array more defined or bigger word of same
  value) of another then truncating them to the same type preserve this
  extension relation.
\end{itemize}
The first property is needed to be able to store smaller words into 64 bit words
variables and it forces the truncation to be the identity when the truncation
type is bigger than the value type.

\begin{figure}[t]
\obeylines\obeyspaces\ttfamily%
let truncate\_val ty v =
~ match v with
~ | Varr s n \_ \(\rightarrow\) if ty = Arr s n then Ok v else Error
~ | Vword s w \(\rightarrow\) if ty is Word s'
~   then Ok (if truncate\_word s' w is Ok w' then Vword s' w' else v) else Error
~ | Vundef \(\rightarrow\) if ty is Arr \_ then Ok Vundef else Error
\normalfont%
\caption{Truncation of values to use with the new contexts.}
\end{figure}

If we chose the truncation to be the identity in the undefined case and the
truncation of a word to a bigger size (where previously it failed) then both
properties are verified.

\medskip

With these modifications we are confident the correctness proof should be
provable. At the writing of this article the correctness proof for the register
allocation step succeded and the proof for the register array expansion is in
progress.

\section{Conclusion}\label{sec:ccl}
% Présentation du travail restant dans le stage ainsi que potentiellement après
% le stage: FIXER LES PREUVES

\end{document}
